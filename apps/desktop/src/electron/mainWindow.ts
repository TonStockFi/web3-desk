import { exec } from 'child_process';
import { app, BrowserWindow, ipcMain, screen, shell, Tray } from 'electron';
import contextMenu from 'electron-context-menu';
import isDev from 'electron-is-dev';
import screenshot from 'screenshot-desktop';

import { getAuthStatus } from 'node-mac-permissions';
import path from 'path';
import { delay } from './utils';
import { client_is_ready, initClients, set_client_is_ready, waitForResult, wsClient } from './ws-server/client';
import { getLocalIPAddress, WebSocketServerWrapper, WsCloseCode } from './ws-server/server';

contextMenu({
    showInspectElement: isDev ? true : true,
    showSaveImageAs: true,
    showSearchWithGoogle: false,
    showLookUpSelection: false,
    showSelectAll: false
});

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
let __DeviceId = '';

const isMac = process.platform === 'darwin';
const isWin = process.platform === 'win32';

export abstract class MainWindow {
    static mainWindow: BrowserWindow | undefined = undefined;
    static tray: Tray;
    static createTray(name?: string) {
        if(!this.tray){
            const tray = new Tray(path.join(process.cwd(), 'public', 'tray-icon.png'));
            tray.setToolTip(name || 'Web3 Explorer');
            tray.on('click', () => {
                console.log('tray clicked');
                const win = this.mainWindow;
                if (win.isMinimized()) {
                    win.restore();
                }
                win.show();
                win.focus();
            });
            this.tray = tray;
        }
      
    }
    static async getDeviceInfo() {
        const {inputIsOpen} = this.getState()
        const {height,width,scale,dpi} = await MainWindow.mainWindow.webContents.executeJavaScript(`(()=>{
            const {width,height} = window.screen
            const devicePixelRatio = window.devicePixelRatio; 
            const dpi = 96 * devicePixelRatio; 
            return {width,height,dpi,scale:devicePixelRatio}
            })()`)
        return {
            inputIsOpen,
            mediaIsStart: true,
            compressQuality: 1,
            delaySendImageDataMs: 1000,
            delayPullEventMs: 1000,
            platform:process.platform,
            arch:process.arch,
            screen: {
                height,
                width,
                scale,
                //todo fix
                dpi
            }
        };
    }
    static openScreenRecordingSettings () {
        exec('open "x-apple.systempreferences:com.apple.preference.security"', (error, stdout, stderr) => {
            if (error) {
                console.error(`Error opening Screen Recording settings: ${error.message}`);
                return;
            }
        });
    };
    static getState () {
        let screenRecordingStatus,accessibilityStatus,screenRecordingIsAuthed,serviceInputIsOpen
        if(isWin){
            screenRecordingIsAuthed = true;
            serviceInputIsOpen = true;
        }else{
            screenRecordingStatus = getAuthStatus('screen');
            accessibilityStatus = getAuthStatus('accessibility');
            screenRecordingIsAuthed =  screenRecordingStatus === 'authorized';
            serviceInputIsOpen = accessibilityStatus === 'authorized';
        }

        return {
            screenRecordingStatus,
            accessibilityStatus,
            mediaIsStart: client_is_ready,
            screenRecordingIsAuthed,
            isWsConnected: wsClient && wsClient.isOpen(),
            isWsReady: wsClient && wsClient.isOpen(),
            inputIsOpen: serviceInputIsOpen
        };
    };
    static async openMainWindow() {
        if (this.mainWindow !== undefined && this.mainWindow !== null) return this.mainWindow;
        const icon = (() => {
            switch (process.platform) {
                case 'darwin':
                    return path.join(process.cwd(), 'public', 'icon.icns');
                case 'linux':
                    return path.join(__dirname, '../../../', 'public', 'icon.png');
                case 'win32':
                    return path.join(process.cwd(), 'public', 'icon.ico');
                default:
                    return '';
            }
        })();

        this.mainWindow = new BrowserWindow({
            titleBarStyle: 'hidden',
                titleBarOverlay: { color: '#232323', symbolColor: '#ffffff' },
                frame: false,
                autoHideMenuBar: true,
                trafficLightPosition: { x: 18, y: 14 },
                x: isDev ? 0 : undefined,
                y: isDev ? 0 : undefined,
                darkTheme: true,
                resizable: false,
                width: 360,
                minWidth: 360,
                height: 740,
                minHeight: 740,
                backgroundColor: '#232323',
                icon,
                webPreferences: {
                    allowRunningInsecureContent: false,
                    experimentalFeatures: false,
                    spellcheck: false,
                    nodeIntegration: true,
                    contextIsolation: true,
                    webviewTag: true,
                    preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
                }
        });
        
        const url = isDev ? 'http://localhost:5173':"https://web3-desk.web3r.site";
        this.mainWindow.loadURL(url);
        this.mainWindow.webContents.on('dom-ready', async () => {
            this.mainWindow.show()
        });
        
        const dispatchEvent = (action: string, payload: any) => {
            this.mainWindow.webContents.executeJavaScript(
                `window.AppCallback(${JSON.stringify({
                    action,
                    payload
                })})`
            );
        };
       
        ipcMain.handle('message', async (e: any, message: { action: string; payload: any }) => {
            const { action, payload } = message;

            // console.log('message', message, {
            //     action,
            //     client_is_ready,
            //     server_is_ready: WebSocketServerWrapper.serverIsReady(),
            //     ...this.getState()
            // });
            switch (action) {
                case 'open_url': {
                    let { url } = payload;
                    await shell.openExternal(url); 
                    break
                }
                case 'get_env': {
                    const sessionPath = this.mainWindow.webContents.session.getStoragePath();
                    const { workAreaSize, workArea } = screen.getPrimaryDisplay();
                    const bounds = this.mainWindow.getBounds();
                    const isFullScreen = this.mainWindow.isFullScreen();
                    return {
                        bounds,
                        version: app.getVersion(),
                        sessionPath,
                        workAreaSize,
                        workArea,
                        dirname: __dirname,
                        ip: getLocalIPAddress(),
                        isMac,
                        isWin,
                        isFullScreen
                    };
                }

                case 'open_screen_recording_settings': {
                    await screenshot()
                    this.openScreenRecordingSettings()
                    return true;
                }

                case 'stop_server': {
                    return WebSocketServerWrapper.stopServer();
                }

                case 'server_is_ready': {
                    return WebSocketServerWrapper.serverIsReady();
                }


                case 'webview_is_ready': {
                    
                    let { apiUrl, deviceId } = payload;
                    if (deviceId) {
                        __DeviceId = deviceId;
                    }
                    return true;
                }
                case 'init_service': {
                    let { apiUrl, password, passwordHash } = payload;
                    console.log('>>init_service', payload, !!wsClient);
                    if (!password) {
                        return;
                    }
                    if (!wsClient || !wsClient.isOpen()) {
                        await initClients(apiUrl, __DeviceId, password, passwordHash);
                    }
                    dispatchEvent('on_state_changed', this.getState());
                    break
                }
                case 'stop_service': {
                    if(wsClient && wsClient.isOpen()){
                        wsClient.sendMessage(
                            JSON.stringify({
                                action: 'close',
                                payload: {
                                    code: WsCloseCode.WS_CLOSE_STOP_RECONNECT,
                                    reason: 'WS_CLOSE_STOP_RECONNECT'
                                }
                            })
                        );
                        console.log('screen closing');
                        await waitForResult(() => {
                            return wsClient.isClosed();
                        });
                    }
                    set_client_is_ready(false)
                    dispatchEvent('on_state_changed', this.getState());
                    break
                }
                case 'check_state': {
                    dispatchEvent('on_state_changed', this.getState());
                    break
                }
                case 'check_service': {
                    return JSON.stringify(this.getState());
                }
            }
        });

        this.mainWindow.on('closed', () => {
            this.mainWindow = undefined;
            ipcMain.removeHandler('message');
        });

        await delay(500);
        return this.mainWindow;
    }
    

    static async bringToFront() {
        if (process.platform === 'win32') {
            if (this.mainWindow) {
                if (this.mainWindow.isMinimized()) this.mainWindow.restore();
            } else {
                // Open main windows
                await this.openMainWindow();
            }

            this.mainWindow.setAlwaysOnTop(true);
            this.mainWindow.focus();
            this.mainWindow.setAlwaysOnTop(false);
        } else {
            await this.openMainWindow();
            this.mainWindow.show();
        }

        return this.mainWindow;
    }
}
